// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "@uniswap/v4-core/PoolManager.sol";
import "@uniswap/v4-core/interfaces/IHooks.sol";
import "@uniswap/v4-core/libraries/Hooks.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";

contract TestERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract MaliciousHook is IHooks {
    function beforeInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96) external returns (bytes4) {
        return IHooks.beforeInitialize.selector;
    }
    
    function afterInitialize(address sender, PoolKey calldata key, uint160 sqrtPriceX96, int24 tick) external returns (bytes4) {
        return IHooks.afterInitialize.selector;
    }
}

contract StateManipulationHook is IHooks {
    uint256 private storedValue;
    
    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params) external returns (bytes4) {
        storedValue = uint256(params.sqrtPriceLimitX96);
        return IHooks.beforeSwap.selector;
    }
    
    function afterSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params, BalanceDelta delta) external returns (bytes4) {
        try IPoolManager(msg.sender).modifyPosition(
            key,
            IPoolManager.ModifyPositionParams({
                tickLower: -1000,
                tickUpper: 1000,
                liquidityDelta: int256(storedValue)
            })
        ) {} catch {}
        return IHooks.afterSwap.selector;
    }
}

contract ReentrancyHook is IHooks {
    bool private attacking;
    
    function executeReentrancyAttack(address poolManager, PoolKey calldata key) external {
        attacking = true;
        IPoolManager(poolManager).swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            })
        );
    }
    
    function beforeSwap(address sender, PoolKey calldata key, IPoolManager.SwapParams calldata params) external returns (bytes4) {
        if (attacking) {
            // Attempt reentrancy
            IPoolManager(msg.sender).swap(key, params);
        }
        return IHooks.beforeSwap.selector;
    }
}

contract HookVulnerabilityTest is Test {
    PoolManager public poolManager;
    TestERC20 public token0;
    TestERC20 public token1;
    
    // Test vectors
    address public attacker;
    address public victim;
    
    function setUp() public {
        // Deploy core contracts
        poolManager = new PoolManager(500000);
        token0 = new TestERC20("Token0", "TK0");
        token1 = new TestERC20("Token1", "TK1");
        
        // Setup test accounts
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        
        // Fund accounts
        vm.deal(attacker, 100 ether);
        vm.deal(victim, 100 ether);
        
        token0.mint(attacker, 1000e18);
        token1.mint(attacker, 1000e18);
        token0.mint(victim, 1000e18);
        token1.mint(victim, 1000e18);
    }

    // Test Category 1: Hook Installation Attacks
    function testMaliciousHookInstallation() public {
        vm.startPrank(attacker);
        
        // Try to install hook with all permissions
        MaliciousHook hook = new MaliciousHook();
        
        PoolKey memory key = PoolKey({
            token0: address(token0),
            token1: address(token1),
            fee: 3000,
            hookAddress: address(hook),
            poolManager: address(poolManager)
        });

        // Test if we can bypass hook address validation
        vm.expectRevert(); // Should revert if protection works
        poolManager.initialize(key, uint160(1 << 96));
        
        vm.stopPrank();
    }

    // Test Category 2: State Manipulation via Hooks
    function testStateManipulationViaHooks() public {
        // Setup pool with potentially vulnerable hook
        StateManipulationHook hook = new StateManipulationHook();
        
        PoolKey memory key = createPool(address(hook));
        
        // Record initial state
        (uint160 initialSqrtPrice,,,) = poolManager.getSlot0(key.toId());
        
        // Attempt state manipulation through hook callbacks
        vm.startPrank(attacker);
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            })
        ) {
            // Check if state was manipulated
            (uint160 newSqrtPrice,,,) = poolManager.getSlot0(key.toId());
            assertEq(newSqrtPrice, initialSqrtPrice, "Hook manipulated price");
        } catch {
            // Log failed attack attempt
        }
        vm.stopPrank();
    }

    // Test Category 3: Reentrancy Attacks
    function testReentrancyViaHooks() public {
        ReentrancyHook hook = new ReentrancyHook();
        PoolKey memory key = createPool(address(hook));

        vm.startPrank(attacker);
        
        // Attempt reentrancy attack through various entry points
        try hook.executeReentrancyAttack(
            address(poolManager),
            key
        ) {
            fail("Reentrancy attack succeeded");
        } catch Error(string memory reason) {
            assertEq(reason, "ReentrancyGuard: reentrant call");
        }
        
        vm.stopPrank();
    }

    // Helper function to create test pool
    function createPool(address hookAddress) internal returns (PoolKey memory) {
        return PoolKey({
            token0: address(token0),
            token1: address(token1),
            fee: 3000,
            hookAddress: hookAddress,
            poolManager: address(poolManager)
        });
    }
} 