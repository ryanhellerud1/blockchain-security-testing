// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "@uniswap/v4-core/contracts/PoolManager.sol";
import "@uniswap/v4-core/contracts/interfaces/IHooks.sol";
import "@uniswap/v4-core/contracts/libraries/Hooks.sol";
import "@uniswap/v4-core/contracts/types/PoolKey.sol";
import "@uniswap/v4-core/contracts/types/Currency.sol";
import "@uniswap/v4-core/contracts/libraries/StateLibrary.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./mocks/MaliciousHooks.sol";

contract TestERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract HookVulnerabilityTest is Test {
    PoolManager public poolManager;
    TestERC20 public token0;
    TestERC20 public token1;
    
    // Hook flags for different operations
    uint160 constant BEFORE_SWAP_FLAG = 1 << 152;
    uint160 constant AFTER_SWAP_FLAG = 1 << 153;
    uint160 constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 154;
    uint160 constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 155;
    uint160 constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 156;
    uint160 constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 157;
    uint160 constant BEFORE_DONATE_FLAG = 1 << 158;
    uint160 constant AFTER_DONATE_FLAG = 1 << 159;
    
    function setUp() public {
        // Deploy core contracts
        poolManager = new PoolManager(address(this)); // Using test contract as protocol fee recipient
        
        // Deploy test tokens
        token0 = new TestERC20("Test0", "TST0");
        token1 = new TestERC20("Test1", "TST1");
        
        // Ensure token0 address is less than token1
        if (address(token0) > address(token1)) {
            (token0, token1) = (token1, token0);
        }
    }

    function testMaliciousHookInstallation() public {
        // Try to create a hook address with all permissions
        address hookAddr = address(uint160(0x1234) | (uint160(0xFF) << 152));
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(hookAddr)
        });

        // This should fail if hook address validation is working
        vm.expectRevert();
        poolManager.initialize(key, uint160(1 << 96));
    }

    function testStateManipulationViaHooks() public {
        // Deploy hook to address with required flags
        uint160 flags = BEFORE_SWAP_FLAG | AFTER_SWAP_FLAG;
        address hookAddr = address(uint160(0x1234) | flags);
        
        // Deploy hook with CREATE2 to get specific address
        bytes memory hookBytecode = type(StateManipulationHook).creationCode;
        bytes32 salt = bytes32(uint256(0x1234));
        
        vm.etch(hookAddr, hookBytecode);
        StateManipulationHook hook = StateManipulationHook(hookAddr);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(hook))
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96));
        
        // Record initial state
        (uint160 initialSqrtPrice,,,) = StateLibrary.getSlot0(poolManager, key.toId());
        
        // Attempt state manipulation through hook callbacks
        vm.startPrank(address(this));
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if state was manipulated
            (uint160 newSqrtPrice,,,) = StateLibrary.getSlot0(poolManager, key.toId());
            assertEq(newSqrtPrice, initialSqrtPrice, "Hook manipulated price");
        } catch {
            // Log failed attack attempt
        }
        vm.stopPrank();
    }

    function testReentrancyViaHooks() public {
        // Deploy hook to address with required flags
        uint160 flags = BEFORE_SWAP_FLAG | AFTER_SWAP_FLAG;
        address hookAddr = address(uint160(0x1234) | flags);
        
        // Deploy hook with CREATE2 to get specific address
        bytes memory hookBytecode = type(ReentrancyHook).creationCode;
        bytes32 salt = bytes32(uint256(0x1234));
        
        vm.etch(hookAddr, hookBytecode);
        ReentrancyHook hook = ReentrancyHook(hookAddr);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(hook))
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96));
        
        vm.startPrank(address(this));
        
        // Attempt reentrancy attack through various entry points
        try hook.executeReentrancyAttack(
            address(poolManager),
            key
        ) {
            assertTrue(false, "Reentrancy attack succeeded");
        } catch Error(string memory reason) {
            assertEq(reason, "ReentrancyGuard: reentrant call");
        }
        
        vm.stopPrank();
    }

    function testFeeManipulationViaHooks() public {
        // Deploy hook to address with required flags
        uint160 flags = BEFORE_SWAP_FLAG | AFTER_SWAP_FLAG;
        address hookAddr = address(uint160(0x1234) | flags);
        
        // Deploy hook with CREATE2 to get specific address
        bytes memory hookBytecode = type(FeeManipulationHook).creationCode;
        bytes32 salt = bytes32(uint256(0x1234));
        
        vm.etch(hookAddr, hookBytecode);
        FeeManipulationHook hook = FeeManipulationHook(hookAddr);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(hook))
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96));
        
        // Mint some tokens for testing
        token0.mint(address(this), 10e18);
        token1.mint(address(this), 10e18);
        
        // Approve tokens
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        vm.startPrank(address(this));
        
        // Record initial balances
        uint256 initialBalance0 = token0.balanceOf(address(this));
        uint256 initialBalance1 = token1.balanceOf(address(this));
        
        // Attempt swap with fee manipulation hook
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if balances were drained
            uint256 finalBalance0 = token0.balanceOf(address(this));
            uint256 finalBalance1 = token1.balanceOf(address(this));
            
            // Ensure the hook didn't steal all value through fees
            assertTrue(
                finalBalance0 > 0 && finalBalance1 > 0,
                "Hook drained all value through fees"
            );
        } catch {
            // Log failed attack attempt
        }
        
        vm.stopPrank();
    }

    function testSandwichAttackViaHooks() public {
        // Deploy hook to address with required flags
        uint160 flags = BEFORE_SWAP_FLAG | AFTER_SWAP_FLAG;
        address hookAddr = address(uint160(0x1234) | flags);
        
        // Deploy hook with CREATE2 to get specific address
        bytes memory hookBytecode = type(SandwichAttackHook).creationCode;
        bytes32 salt = bytes32(uint256(0x1234));
        
        vm.etch(hookAddr, hookBytecode);
        SandwichAttackHook hook = SandwichAttackHook(hookAddr);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(address(hook))
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96));
        
        // Setup victim account
        address victim = makeAddr("victim");
        token0.mint(victim, 10e18);
        token1.mint(victim, 10e18);
        
        vm.startPrank(victim);
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        // Record initial balances
        uint256 initialBalance0 = token0.balanceOf(victim);
        uint256 initialBalance1 = token1.balanceOf(victim);
        
        // Attempt swap that could be sandwiched
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if victim was sandwiched (lost more value than expected)
            uint256 finalBalance0 = token0.balanceOf(victim);
            uint256 finalBalance1 = token1.balanceOf(victim);
            
            uint256 balance0Delta = initialBalance0 - finalBalance0;
            uint256 balance1Delta = finalBalance1 - initialBalance1;
            
            // Ensure the hook didn't extract excessive value through sandwiching
            assertTrue(
                balance0Delta <= 1.1e18 && balance1Delta <= 1.1e18,
                "Hook extracted excessive value through sandwiching"
            );
        } catch {
            // Log failed attack attempt
        }
        
        vm.stopPrank();
    }
} 