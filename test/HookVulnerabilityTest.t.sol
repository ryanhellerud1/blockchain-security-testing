// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

/**
 * @title Uniswap V4 Hook Vulnerability Tests
 * @notice Test suite for identifying potential vulnerabilities in Uniswap V4's hook system
 * @dev These tests attempt various attack vectors against Uniswap V4's hook mechanism
 */

import "forge-std/Test.sol";
import "@uniswap/v4-core/contracts/PoolManager.sol";
import "@uniswap/v4-core/contracts/interfaces/IHooks.sol";
import "@uniswap/v4-core/contracts/libraries/Hooks.sol";
import "@uniswap/v4-core/contracts/types/PoolKey.sol";
import "@uniswap/v4-core/contracts/types/Currency.sol";
import "@uniswap/v4-core/contracts/libraries/StateLibrary.sol";
import "@uniswap/v4-core/contracts/types/PoolId.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./mocks/MaliciousHooks.sol";

using PoolIdLibrary for PoolKey;

/// @notice Simple ERC20 token for testing
contract TestERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

/**
 * @title Hook Vulnerability Test Suite
 * @notice A comprehensive test suite for identifying potential vulnerabilities in Uniswap V4's hook system
 * @dev Tests various attack vectors including:
 * - Malicious hook installation
 * - State manipulation
 * - Reentrancy attacks
 * - Fee manipulation
 * - Sandwich attacks
 */
contract HookVulnerabilityTest is Test {
    PoolManager public poolManager;
    TestERC20 public token0;
    TestERC20 public token1;
    
    // Hook flags for different operations (using Uniswap v4's actual flag positions)
    // These flags determine which hooks can be called by setting specific bits in the hook address
    uint160 constant BEFORE_INITIALIZE_FLAG = 1 << 13;
    uint160 constant AFTER_INITIALIZE_FLAG = 1 << 12;
    uint160 constant BEFORE_ADD_LIQUIDITY_FLAG = 1 << 11;
    uint160 constant AFTER_ADD_LIQUIDITY_FLAG = 1 << 10;
    uint160 constant BEFORE_REMOVE_LIQUIDITY_FLAG = 1 << 9;
    uint160 constant AFTER_REMOVE_LIQUIDITY_FLAG = 1 << 8;
    uint160 constant BEFORE_SWAP_FLAG = 1 << 7;
    uint160 constant AFTER_SWAP_FLAG = 1 << 6;
    uint160 constant BEFORE_DONATE_FLAG = 1 << 5;
    uint160 constant AFTER_DONATE_FLAG = 1 << 4;
    uint160 constant BEFORE_SWAP_RETURNS_DELTA_FLAG = 1 << 3;
    uint160 constant AFTER_SWAP_RETURNS_DELTA_FLAG = 1 << 2;
    uint160 constant AFTER_ADD_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 1;
    uint160 constant AFTER_REMOVE_LIQUIDITY_RETURNS_DELTA_FLAG = 1 << 0;

    // Fixed hook address with all flags enabled for testing
    uint160 constant HOOK_ADDRESS_MASK = (uint160(0xFE) << 152) | uint160(0x3ffF);
    address constant HOOK_ADDRESS = address(HOOK_ADDRESS_MASK);
    
    // Custom errors that match Uniswap V4's error definitions
    error ManagerLocked();
    
    function setUp() public {
        // Deploy core contracts
        poolManager = new PoolManager(100000); // Using test contract as protocol fee recipient
        
        // Deploy test tokens
        token0 = new TestERC20("Test0", "TST0");
        token1 = new TestERC20("Test1", "TST1");
        
        // Ensure token0 address is less than token1 (Uniswap V4 requirement)
        if (address(token0) > address(token1)) {
            (token0, token1) = (token1, token0);
        }
    }

    /**
     * @notice Tests if a malicious hook can be installed with unauthorized permissions
     * @dev Attempts to create a hook with all permissions and verifies it's properly validated
     */
    function testMaliciousHookInstallation() public {
        // Try to create a hook address with all permissions
        address hookAddr = HOOK_ADDRESS;
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(hookAddr)
        });

        // Deploy hook implementation to the fixed address
        StateManipulationHookImpl impl = new StateManipulationHookImpl();
        vm.etch(hookAddr, address(impl).code);

        // Initialize pool - should succeed since we're using valid flags
        poolManager.initialize(key, uint160(1 << 96), "");
    }

    /**
     * @notice Tests if a hook can manipulate pool state outside of allowed operations
     * @dev Attempts to modify pool state through hook callbacks and verifies state integrity
     */
    function testStateManipulationViaHooks() public {
        // Deploy hook to fixed address with required flags
        StateManipulationHookImpl impl = new StateManipulationHookImpl();
        vm.etch(HOOK_ADDRESS, address(impl).code);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(HOOK_ADDRESS)
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        // Record initial state
        (uint160 initialSqrtPrice,,,) = StateLibrary.getSlot0(poolManager, key.toId());
        
        // Attempt state manipulation through hook callbacks
        vm.startPrank(address(this));
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if state was manipulated
            (uint160 newSqrtPrice,,,) = StateLibrary.getSlot0(poolManager, key.toId());
            assertEq(newSqrtPrice, initialSqrtPrice, "Hook manipulated price");
        } catch {
            // Log failed attack attempt
        }
        vm.stopPrank();
    }

    /**
     * @notice Tests if a hook can perform reentrancy attacks
     * @dev Attempts to reenter the pool manager during hook callbacks
     */
    function testReentrancyViaHooks() public {
        // Deploy hook to fixed address with required flags
        ReentrancyHookImpl impl = new ReentrancyHookImpl();
        vm.etch(HOOK_ADDRESS, address(impl).code);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(HOOK_ADDRESS)
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        vm.startPrank(address(this));
        
        // Attempt reentrancy attack - should revert with ManagerLocked
        vm.expectRevert(ManagerLocked.selector);
        ReentrancyHookImpl(HOOK_ADDRESS).executeReentrancyAttack(
            address(poolManager),
            key
        );
        
        vm.stopPrank();
    }

    /**
     * @notice Tests if a hook can manipulate fees to drain user funds
     * @dev Attempts to extract excessive fees through hook callbacks
     */
    function testFeeManipulationViaHooks() public {
        // Deploy hook to fixed address with required flags
        FeeManipulationHookImpl impl = new FeeManipulationHookImpl();
        vm.etch(HOOK_ADDRESS, address(impl).code);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(HOOK_ADDRESS)
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        // Mint some tokens for testing
        token0.mint(address(this), 10e18);
        token1.mint(address(this), 10e18);
        
        // Approve tokens
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        vm.startPrank(address(this));
        
        // Record initial balances
        uint256 initialBalance0 = token0.balanceOf(address(this));
        uint256 initialBalance1 = token1.balanceOf(address(this));
        
        // Attempt swap with fee manipulation hook
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if balances were drained
            uint256 finalBalance0 = token0.balanceOf(address(this));
            uint256 finalBalance1 = token1.balanceOf(address(this));
            
            // Ensure the hook didn't steal all value through fees
            assertTrue(
                finalBalance0 > 0 && finalBalance1 > 0,
                "Hook drained all value through fees"
            );
        } catch {
            // Log failed attack attempt
        }
        
        vm.stopPrank();
    }

    /**
     * @notice Tests if a hook can perform sandwich attacks
     * @dev Attempts to extract value through front-running and back-running trades
     */
    function testSandwichAttackViaHooks() public {
        // Deploy hook to fixed address with required flags
        SandwichAttackHookImpl impl = new SandwichAttackHookImpl();
        vm.etch(HOOK_ADDRESS, address(impl).code);
        
        PoolKey memory key = PoolKey({
            currency0: Currency.wrap(address(token0)),
            currency1: Currency.wrap(address(token1)),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(HOOK_ADDRESS)
        });

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        // Setup victim account
        address victim = makeAddr("victim");
        token0.mint(victim, 10e18);
        token1.mint(victim, 10e18);
        
        vm.startPrank(victim);
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        // Record initial balances
        uint256 initialBalance0 = token0.balanceOf(victim);
        uint256 initialBalance1 = token1.balanceOf(victim);
        
        // Attempt swap that could be sandwiched
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            }),
            ""
        ) {
            // Check if victim was sandwiched (lost more value than expected)
            uint256 finalBalance0 = token0.balanceOf(victim);
            uint256 finalBalance1 = token1.balanceOf(victim);
            
            uint256 balance0Delta = initialBalance0 - finalBalance0;
            uint256 balance1Delta = finalBalance1 - initialBalance1;
            
            // Ensure the hook didn't extract excessive value through sandwiching
            assertTrue(
                balance0Delta <= 1.1e18 && balance1Delta <= 1.1e18,
                "Hook extracted excessive value through sandwiching"
            );
        } catch {
            // Log failed attack attempt
        }
        
        vm.stopPrank();
    }
} 