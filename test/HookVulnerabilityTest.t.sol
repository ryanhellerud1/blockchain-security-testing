// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "forge-std/Test.sol";
import "../src/PoolManager.sol";
import "../src/interfaces/IHooks.sol";
import "../src/libraries/Hooks.sol";

contract HookVulnerabilityTest is Test {
    PoolManager public poolManager;
    TestERC20 public token0;
    TestERC20 public token1;
    
    // Test vectors
    address public attacker;
    address public victim;
    
    function setUp() public {
        // Deploy core contracts
        poolManager = new PoolManager(500000);
        token0 = new TestERC20("Token0", "TK0");
        token1 = new TestERC20("Token1", "TK1");
        
        // Setup test accounts
        attacker = makeAddr("attacker");
        victim = makeAddr("victim");
        
        // Fund accounts
        vm.deal(attacker, 100 ether);
        vm.deal(victim, 100 ether);
        
        token0.mint(attacker, 1000e18);
        token1.mint(attacker, 1000e18);
        token0.mint(victim, 1000e18);
        token1.mint(victim, 1000e18);
    }

    // Test Category 1: Hook Installation Attacks
    function testMaliciousHookInstallation() public {
        vm.startPrank(attacker);
        
        // Try to install hook with all permissions
        MaliciousHook hook = new MaliciousHook();
        
        PoolKey memory key = PoolKey({
            token0: address(token0),
            token1: address(token1),
            fee: 3000,
            hookAddress: address(hook),
            poolManager: address(poolManager)
        });

        // Test if we can bypass hook address validation
        vm.expectRevert(); // Should revert if protection works
        poolManager.initialize(key, uint160(1 << 96));
        
        vm.stopPrank();
    }

    // Test Category 2: State Manipulation via Hooks
    function testStateManipulationViaHooks() public {
        // Setup pool with potentially vulnerable hook
        StateManipulationHook hook = new StateManipulationHook();
        
        PoolKey memory key = createPool(address(hook));
        
        // Record initial state
        (uint160 initialSqrtPrice,,,) = poolManager.getSlot0(key.toId());
        
        // Attempt state manipulation through hook callbacks
        vm.startPrank(attacker);
        try poolManager.swap(
            key,
            IPoolManager.SwapParams({
                zeroForOne: true,
                amountSpecified: 1e18,
                sqrtPriceLimitX96: 0
            })
        ) {
            // Check if state was manipulated
            (uint160 newSqrtPrice,,,) = poolManager.getSlot0(key.toId());
            assertEq(newSqrtPrice, initialSqrtPrice, "Hook manipulated price");
        } catch {
            // Log failed attack attempt
        }
        vm.stopPrank();
    }

    // Test Category 3: Reentrancy Attacks
    function testReentrancyViaHooks() public {
        ReentrancyHook hook = new ReentrancyHook();
        PoolKey memory key = createPool(address(hook));

        vm.startPrank(attacker);
        
        // Attempt reentrancy attack through various entry points
        try hook.executeReentrancyAttack(
            address(poolManager),
            key
        ) {
            fail("Reentrancy attack succeeded");
        } catch Error(string memory reason) {
            assertEq(reason, "ReentrancyGuard: reentrant call");
        }
        
        vm.stopPrank();
    }

    // Helper function to create test pool
    function createPool(address hookAddress) internal returns (PoolKey memory) {
        return PoolKey({
            token0: address(token0),
            token1: address(token1),
            fee: 3000,
            hookAddress: hookAddress,
            poolManager: address(poolManager)
        });
    }
} 