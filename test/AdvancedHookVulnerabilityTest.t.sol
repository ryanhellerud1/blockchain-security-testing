// SPDX-License-Identifier: MIT
pragma solidity ^0.8.24;

import "forge-std/Test.sol";
import "@uniswap/v4-core/contracts/PoolManager.sol";
import "@uniswap/v4-core/contracts/interfaces/IHooks.sol";
import "@uniswap/v4-core/contracts/libraries/Hooks.sol";
import "@uniswap/v4-core/contracts/types/PoolKey.sol";
import "@uniswap/v4-core/contracts/types/Currency.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "./mocks/AdvancedMaliciousHooks.sol";

contract TestERC20 is ERC20 {
    constructor(string memory name, string memory symbol) ERC20(name, symbol) {}
    
    function mint(address to, uint256 amount) public {
        _mint(to, amount);
    }
}

contract AdvancedHookVulnerabilityTest is Test {
    PoolManager public poolManager;
    TestERC20 public token0;
    TestERC20 public token1;
    TestERC20 public token2;
    TestERC20 public token3;
    
    // Hook flags using the same bit positions as HookVulnerabilityTest.t.sol
    uint160 constant HOOK_ADDRESS_MASK = (uint160(0xFE) << 152) | uint160(0x3ffF);
    
    function deployHookWithFlags(bytes memory creationCode) internal returns (address) {
        // Deploy the hook with flags already set
        bytes memory code = abi.encodePacked(
            creationCode,
            abi.encode(address(this))  // Constructor argument
        );
        
        address hook;
        assembly {
            hook := create(0, add(code, 0x20), mload(code))
            if iszero(extcodesize(hook)) {
                revert(0, 0)
            }
        }
        
        // Set the hook flags
        return address(uint160(hook) | HOOK_ADDRESS_MASK);
    }
    
    function setUp() public {
        poolManager = new PoolManager(100000);
        token0 = new TestERC20("Token0", "TK0");
        token1 = new TestERC20("Token1", "TK1");
        token2 = new TestERC20("Token2", "TK2");
        token3 = new TestERC20("Token3", "TK3");
        
        if (address(token0) > address(token1)) {
            (token0, token1) = (token1, token0);
        }
    }

    function createPoolKey(address token0Addr, address token1Addr, address hookAddr) internal pure returns (PoolKey memory) {
        return PoolKey({
            currency0: Currency.wrap(token0Addr),
            currency1: Currency.wrap(token1Addr),
            fee: 3000,
            tickSpacing: 60,
            hooks: IHooks(hookAddr)
        });
    }

    function testFlashLoanAttack() public {
        // Deploy flash loan attack hook with flags
        address hookAddr = deployHookWithFlags(type(FlashLoanAttackHook).creationCode);
        
        // Setup multiple pools for the attack
        PoolKey[] memory pools = new PoolKey[](2);
        pools[0] = createPoolKey(address(token0), address(token1), hookAddr);
        pools[1] = createPoolKey(address(token2), address(token3), hookAddr);

        // Initialize pools
        poolManager.initialize(pools[0], uint160(1 << 96), "");
        poolManager.initialize(pools[1], uint160(1 << 96), "");
        
        // Setup liquidity
        token0.mint(address(this), 100e18);
        token1.mint(address(this), 100e18);
        token2.mint(address(this), 100e18);
        token3.mint(address(this), 100e18);
        
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        token2.approve(address(poolManager), type(uint256).max);
        token3.approve(address(poolManager), type(uint256).max);
        
        // Prepare flash loan attack parameters
        IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: 50e18,
            sqrtPriceLimitX96: 0
        });
        
        // Attempt flash loan attack
        FlashLoanAttackHook(hookAddr).beforeSwap(
            address(this),
            pools[0],
            params,
            bytes("")
        );
    }

    function testOracleManipulation() public {
        // Deploy oracle manipulation hook with flags
        address hookAddr = deployHookWithFlags(type(OracleManipulationHook).creationCode);
        
        PoolKey memory key = createPoolKey(address(token0), address(token1), hookAddr);

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        // Setup liquidity
        token0.mint(address(this), 100e18);
        token1.mint(address(this), 100e18);
        
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        // Prepare oracle manipulation parameters
        IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: 10e18,
            sqrtPriceLimitX96: 0
        });
        
        // Attempt oracle manipulation
        OracleManipulationHook(hookAddr).beforeSwap(
            address(this),
            key,
            params,
            bytes("")
        );
    }

    function testMultiPoolSandwich() public {
        // Deploy sandwich attack hook with flags
        address hookAddr = deployHookWithFlags(type(MultiPoolSandwichHook).creationCode);
        
        // Setup multiple pools for the attack
        PoolKey[] memory pools = new PoolKey[](2);
        pools[0] = createPoolKey(address(token0), address(token1), hookAddr);
        pools[1] = createPoolKey(address(token2), address(token3), hookAddr);

        // Initialize pools
        poolManager.initialize(pools[0], uint160(1 << 96), "");
        poolManager.initialize(pools[1], uint160(1 << 96), "");
        
        // Setup liquidity
        token0.mint(address(this), 100e18);
        token1.mint(address(this), 100e18);
        token2.mint(address(this), 100e18);
        token3.mint(address(this), 100e18);
        
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        token2.approve(address(poolManager), type(uint256).max);
        token3.approve(address(poolManager), type(uint256).max);
        
        // Prepare sandwich attack parameters
        IPoolManager.SwapParams memory params = IPoolManager.SwapParams({
            zeroForOne: true,
            amountSpecified: 1e18,
            sqrtPriceLimitX96: 0
        });
        
        // Attempt sandwich attack
        MultiPoolSandwichHook(hookAddr).beforeSwap(
            address(this),
            pools[0],
            params,
            bytes("")
        );
    }

    function testLiquiditySnipingAttack() public {
        // Deploy liquidity sniping hook with flags
        address hookAddr = deployHookWithFlags(type(LiquiditySnipingHook).creationCode);
        
        PoolKey memory key = createPoolKey(address(token0), address(token1), hookAddr);

        // Initialize pool
        poolManager.initialize(key, uint160(1 << 96), "");
        
        // Setup liquidity
        token0.mint(address(this), 100e18);
        token1.mint(address(this), 100e18);
        
        token0.approve(address(poolManager), type(uint256).max);
        token1.approve(address(poolManager), type(uint256).max);
        
        // Prepare liquidity sniping parameters
        IPoolManager.ModifyLiquidityParams memory params = IPoolManager.ModifyLiquidityParams({
            tickLower: -100,
            tickUpper: 100,
            liquidityDelta: int256(1e18),
            salt: bytes32(0)
        });
        
        // Attempt liquidity sniping
        LiquiditySnipingHook(hookAddr).beforeAddLiquidity(
            address(this),
            key,
            params,
            bytes("")
        );
    }
} 